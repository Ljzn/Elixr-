#二进制，字符串和字符列表

    1. UTF-8和Unicode
    2. 二进制数(和位串)
    3. 字符列表

在“基本类型”一章，我们学会使用`is_binary/1`函数来检查字符串：

```
iex> string = "hello"
"hello"
iex> is_binary(string)
true
```

本章，我们将介绍什么是二进制数，它们是如何与字符串相联系的，还有单引号的值，`like this`，在Elixir中代表什么。

#UTF-8和Unicode

一个字符串是一段UTF-8编码的二进制数。为了理解它们，我们首先需要明白字节与代码点的区别。

Unicode标准将代码点赋值给许多我们熟知的字符。例如，字母`a`拥有代码点`97`，字母`ł`拥有代码点`322`。当将字符串`"hełło"`写入磁盘时，我们需要将代码点转换为字节。如果我们遵守一个字节代表一个代码点的规则，那么我们就不能写入`"hełło"`，因为`ł`的代码点是`322`，而一个字节只能表示`0`到`255`的数字。但我们总有办法表示`"hełło"`，这就是编码在发挥作用。

当用字节来表示代码点时，我们需要对它们进行编码。Elixir选择UTF-8编码作为其主要和默认的编码。当我们说一个字符串是UTF-8编码的二进制数，那意味着它是一串通过UTF-8编码来代表特定代码点的字节。

我们需要不止一个字节来代表例如`ł`的`322`这样的代码点。这就是`byte_size/1`与`String.length/1`返回值不同的原因：

```
iex> string = "hełło"
"hełło"
iex> byte_size(string)
7
iex> String.length(string)
5
```

UTF-8要求以一个字节来表示`h`，`e`和`o`的代码点，以两个字节表示`ł`的。在Elixir中，你可以通过`?`来得到代码点的值：

```
iex> ?a
97
iex> ?ł
322
```

你也可以使用`String`模块中的函数来依照代码点分割一个字符串：

```
iex> String.codepoints("hełło")
["h", "e", "ł", "ł", "o"]
```

你会发现Elixir对于字符串操作有着良好的支持。事实上，Elixir将所有测试内容放到了文章“字符串类型崩溃了”中。

然而，字符串只是故事的一部分。我们通过`is_binary/1`得知字符串是二进制数，所以Elixir一定是以一种底层类型控制着字符串。让我们来讨论一下二进制数！

#二进制数(和位串)

在Elixir中，你可以用`<<>>`来定义二进制数：

```
iex> <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> byte_size(<<0, 1, 2, 3>>)
4
```

一个二进制数只不过是连续的字节。这些字节可以以任何形式组合，即使不形成一个合法的字符串：

```
iex> String.valid?(<<239, 191, 191>>)
false
```

字符串连接符实际上是二进制数连接符：

```
iex> <<0, 1>> <> <<2, 3>>
<<0, 1, 2, 3>>
```

Elixir中有一个技巧是将字符串与空字节`<<0>>`相连接，以查看字符串内部的二进制数：

```
iex> "hełło" <> <<0>>
<<104, 101, 197, 130, 197, 130, 111, 0>>
```

二进制数中的每个数字代表一个字节，因此上限是255.二进制数允许修改存储大小来存放大于255的数，或将代码点以utf8格式表示：

```
iex> <<255>>
<<255>>
iex> <<256>> # truncated
<<0>>
iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
<<1, 0>>
iex> <<256 :: utf8>> # the number is a code point
"Ā"
iex> <<256 :: utf8, 0>>
<<196, 128, 0>>
```

如果一个字节有8位，那么将其传送至1位空间会发生什么？

```
iex> <<1 :: size(1)>>
<<1::size(1)>>
iex> <<2 :: size(1)>> # truncated
<<0::size(1)>>
iex> is_binary(<< 1 :: size(1)>>)
false
iex> is_bitstring(<< 1 :: size(1)>>)
true
iex> bit_size(<< 1 :: size(1)>>)
1
```

其值不再是二进制数，而是位串——只是一串位！所以一个二进制数是一个位数为8的倍数的位串。

我们也可以对二进制数与位串进行模式匹配：

```
iex> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>
iex> x
2
iex> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
```

注意二进制数匹配中的每个入口都期望匹配到8bit。如果我们想要匹配一个未知大小的二进制数，可以在模式的结尾使用二进制数修改器：

```
iex> <<0, 1, x :: binary>> = <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> x
<<2, 3>>
```

可以用字符串连接符达到类似的效果：

```
iex> "he" <> rest = "hello"
"hello"
iex> rest
"llo"
```

关于二进制数／位串构造符`<<>>`的完整介绍可以在Elixir文档中找到。总结一下位串，二进制数和字符串。一个字符串是一个以UTF-8格式编码的二进制数，而一个二进制数是一个位数为8的倍数的位串。尽管我们展示了Elixir处理bit位和字节的灵活性，但99%的时间你都在和二进制数打交道，并且使用`is_binary/1`和`byte_size/1`函数。

#字符列表

字符列表仅仅是字符的列表：

```
iex> 'hełło'
[104, 101, 322, 322, 111]
iex> is_list 'hełło'
true
iex> 'hello'
'hello'
```

可以看出，一个字符列表包含了单引号间的字符的代码点，而非字节(注意如果某个字符超出了ASCII的范围，IEx将只输出其代码点)。所以双引号代表一个字符串(二进制数)，单引号代表一个字符列表(列表)。

在实践中，字符列表通常用于与Erlang的接口，因为一些旧的库不接受二进制数作为参数。你可以使用`to_string/1`和`to_char_list/1`函数来相互转化字符列表和字符串：

```
iex> to_char_list "hełło"
[104, 101, 322, 322, 111]
iex> to_string 'hełło'
"hełło"
iex> to_string :hello
"hello"
iex> to_string 1
"1"
```

注意这些函数是多态的。它们不仅能将字符列表转换成字符串，也能将整数，原子等转换成字符串。

介绍完二进制数，字符串和字符列表，接下来将讨论的是键值对数据结构。
